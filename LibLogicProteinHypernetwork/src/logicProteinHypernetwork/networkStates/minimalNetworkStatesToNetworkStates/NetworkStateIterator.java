/* Copyright (c) 2010, Johannes Köster <johannes.koester@tu-dortmund.de>
 * All rights reserved.
 *
 * This software is open-source under the BSD license; see "license.txt"
 * for a description.
 */
package logicProteinHypernetwork.networkStates.minimalNetworkStatesToNetworkStates;

import java.util.Arrays;
import java.util.Iterator;
import logicProteinHypernetwork.networkStates.MinimalNetworkState;
import logicProteinHypernetwork.networkStates.NetworkState;

/**
 * An iterator over network states that are generated by the InstructionTree.
 *
 * @author Johannes Köster <johannes.koester@tu-dortmund.de>
 */
public class NetworkStateIterator implements Iterator<NetworkState> {

  private InstructionTree it;
  private PathIterator paths;

  /**
   * Constructor of class NetworkStateIterator.
   *
   * @param it the instruction tree
   */
  public NetworkStateIterator(InstructionTree it) {
    this.it = it;
    paths = new PathIterator(it.getTree());
  }

  /**
   * Returns the number of leafs.
   *
   * @return the number of leafs
   */
  public long size() {
    return it.getLeafs();
  }

  @Override
  public boolean hasNext() {
    return paths.hasNext();
  }

  @Override
  public NetworkState next() {
    MinimalNetworkState[] validWorlds = Arrays.copyOf(it.getStates(), it.getStates().length);

    Iterator<Instruction> path = paths.next();
    while (path.hasNext()) {
      validWorlds[path.next().remove] = null;
    }

    NetworkState state = new NetworkState();

    for (MinimalNetworkState w : validWorlds) {
      if (w != null) {
        state.add(w);
      }
    }

    // debug: detect clashes here
    /*for (int i = 0; i < validWorlds.length; i++) {
      for (int j = i + 1; j < validWorlds.length; j++) {
        if (validWorlds[i] != null && validWorlds[j] != null && validWorlds[i].isClash(validWorlds[j])) {
          System.err.println("Error: clash in merged worlds!!");
        }
      }
    }

    int i = 0;
    for (MinimalNetworkState s : it.getStates()) {
      boolean clash = false;
      boolean contained = false;
      for (MinimalNetworkState w : validWorlds) {
        if (w != null) {
          if (w.equals(s)) {
            contained = true;
          }
          if (w.isClash(s)) {
            clash = true;
          }
        }
      }
      if (!contained && !clash) {
        System.err.println("Error: merged worlds incomplete!!");
        System.err.println(i);
        //it.removeInvalid();
      }
      i++;
    }*/

    return state;
  }

  @Override
  public void remove() {
    throw new UnsupportedOperationException("Not supported.");
  }
}
